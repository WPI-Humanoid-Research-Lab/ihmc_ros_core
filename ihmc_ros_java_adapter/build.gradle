buildscript {
    repositories {
        maven { url "https://plugins.gradle.org/m2/" }
        mavenCentral()
    }

    dependencies {
        classpath "org.yaml:snakeyaml:1.6"
        classpath "gradle.plugin.us.ihmc:ihmc-build:0.10.4"
    }
}

apply plugin: 'java'
apply plugin: "us.ihmc.ihmc-build"

repositories {
    maven {
        url "http://dl.bintray.com/ihmcrobotics/maven-vendor"
    }

    maven {
        url "http://dl.bintray.com/ihmcrobotics/maven-release"
    }

    maven {
        url "https://artifactory.ihmc.us/artifactory/snapshots/"
    }

    maven {
        url "https://artifactory.ihmc.us/artifactory/thirdparty/"
    }

    maven {
        url "https://artifactory.ihmc.us/artifactory/releases/"
    }

    maven {
        url "https://github.com/rosjava/rosjava_mvn_repo/raw/master"
    }

    maven {
        url "http://clojars.org/repo/"
    }

    maven {
        url 'http://updates.jmonkeyengine.org/maven'
    }

    mavenLocal()

    jcenter()

    mavenCentral()
}

if(!gradle.startParameter.taskNames.contains("warmUp"))
{
    gradle.startParameter.excludedTaskNames << "warmUp"
    project.ext.doWarmup = false
}
else
{
    project.ext.doWarmup = true
}

configurations {
    all*.exclude group: 'org.bytedeco', module: 'javacpp-presets'
}

/*
 * Disable all of the tasks on the subproject so that invoking gradle commands on this project are quicker.
 * Because integration with the subproject is optional and is achieved using a GradleBuild type task, we
 * don't need to run the tasks here. We invoke them from the buildSourceProject.
 *
 * Also grabs a reference to the top level project of all the subprojects so we can get at its build script
 * later.
 */
// subprojects { subproject ->
//     rootProject.configure(subproject, {
//         subproject.tasks.each {task ->
//             task.enabled = false
//         }
//     })

//     if(subproject.getParent().equals(rootProject)) {
//         rootProject.ext.set("sourceProject", subproject)
//     }
// }

task wrapper(type: Wrapper) {
    gradleVersion = '4.3'
}

task buildSourceProject {
    if(project.gradle.includedBuilds.empty)
    {
        return
    }

    dependsOn project.gradle.includedBuilds*.task(':publishToMavenLocal')
}

import us.ihmc.ros.java_adapter.yaml.IHMCROSJavaYamlLoader

task parseYaml(dependsOn: buildSourceProject) {
    if(!project.hasProperty("yaml")) {
        return
    }
    project.ext.configHolder = new IHMCROSJavaYamlLoader().loadYaml(project.yaml)
    configurations.create("ros")
    configurations.ros {
        exclude group: 'org.bytedeco', module: 'javacpp-presets'
    }

    project.configHolder.dependencyHolder.dependencies.each { dep ->
        def gavStrings = dep.split(":")
        def group = gavStrings[0];
        def artifact = gavStrings[1];
        def version = gavStrings[2];

        if(project.hasProperty("useLocal") && project.useLocal.toLowerCase().equals("true"))
        {
            if(group.equals("us.ihmc")) {
                version = "LOCAL"
            }
        }

        def dependencyString = "${group}:${artifact}:${version}"

        project.dependencies.add("ros", dependencyString)
    }
}

task warmUp(dependsOn: parseYaml) {
    if(!project.doWarmup)
    {
        return;
    }
    configurations.ros {
        exclude group: 'org.bytedeco', module: 'javacpp-presets'
    }
    configurations.ros.resolve()
}

task runJava(type: GradleBuild) {
    if(!project.hasProperty("yaml")) {
        return
    }
    buildFile "build.gradle"
    def allTasks = new ArrayList<String>()

    if(project.hasProperty("useLocal") && project.useLocal.toLowerCase().equals("true")) {
        allTasks.add("buildSourceProject")
    }

    allTasks.add("runJavaDelegate")

    startParameter gradle.startParameter

    tasks = allTasks
}

task runJavaDelegate(type: JavaExec, dependsOn: parseYaml) {
    if(!project.hasProperty("yaml")) {
        return
    }
    ignoreExitValue = true
    classpath = configurations.ros
    workingDir = project.projectDir

    def heapSizeFromYaml = project.configHolder.vmConfiguration.heapSize
    if(heapSizeFromYaml != null)
    {
        maxHeapSize = heapSizeFromYaml
    }

    main = project.configHolder.vmConfiguration.mainMethod
    System.properties.each { property ->
        if((property.key as String).startsWith("us.ihmc")) {
            systemProperties[property.key as String] = property.value
        }
    }
    args = []
    if(project.hasProperty("programArgs")) {
        args project.programArgs.split(",")
    }
    else {
        String[] argArray = new String[project.configHolder.programArguments.size()]
        argArray = project.configHolder.programArguments.toArray(argArray)
        args argArray
    }
}

// parseYaml.mustRunAfter buildSourceProject

// gradle.taskGraph.whenReady { TaskExecutionGraph graph ->
//     if(graph.hasTask(parseYaml) && !project.hasProperty("yaml")) {
//         throw new GradleException("Attempting to use the Java execution adapter without setting the yaml location property. Please set the project property \"yaml\" to the location of the yaml configuration.\nFor more information on Gradle properties see https://docs.gradle.org/current/userguide/build_environment.html")
//     }

//     if(graph.hasTask(buildSourceProject) && subprojects.empty) {
//         throw new GradleException("Cannot build local source project, no subprojects are configured. Please set the IHMC_SOURCE_LOCATION environment variable.")
//     }
// }
